<!doctype html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Admin | Tour Leads</title>
    <style>
      :root {
        --bg: #f7f4ec;
        --ink: #171614;
        --muted: #575146;
        --line: rgba(23, 22, 20, 0.15);
        --card: #ffffff;
        --accent: #0c6c5a;
        --danger: #a0392a;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Manrope", sans-serif;
        color: var(--ink);
        background: var(--bg);
      }

      .wrap {
        width: min(1200px, 95vw);
        margin: 24px auto 48px;
        display: grid;
        gap: 12px;
      }

      .panel {
        border: 1px solid var(--line);
        border-radius: 12px;
        background: var(--card);
        padding: 14px;
      }

      h1,
      h2,
      p {
        margin: 0;
      }

      .small {
        color: var(--muted);
        font-size: 13px;
      }

      .controls {
        display: grid;
        grid-template-columns: 220px 200px 1fr auto auto;
        gap: 8px;
      }

      input,
      select,
      button,
      textarea {
        width: 100%;
        border: 1px solid var(--line);
        border-radius: 8px;
        font: inherit;
        padding: 9px 10px;
      }

      textarea {
        resize: vertical;
      }

      button {
        background: var(--accent);
        color: #fff;
        cursor: pointer;
        border: 0;
      }

      button.secondary {
        background: #e6843f;
      }

      button.danger {
        background: var(--danger);
      }

      .table-wrap {
        overflow: auto;
      }

      table {
        border-collapse: collapse;
        width: 100%;
        min-width: 1050px;
      }

      th,
      td {
        border-bottom: 1px solid var(--line);
        text-align: left;
        vertical-align: top;
        padding: 8px;
        font-size: 13px;
      }

      th {
        position: sticky;
        top: 0;
        background: #fff;
      }

      .status {
        font-weight: 700;
        text-transform: uppercase;
        font-size: 11px;
      }

      .status-new {
        color: #0a6f9f;
      }

      .status-contacted {
        color: #9b6f00;
      }

      .status-booked {
        color: #0f7d42;
      }

      .status-archived {
        color: #8b8b8b;
      }

      .actions {
        display: flex;
        gap: 6px;
      }

      .locations-toolbar {
        display: grid;
        grid-template-columns: 1fr auto auto;
        gap: 8px;
        margin-bottom: 10px;
      }

      .spots-grid {
        display: grid;
        gap: 10px;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      }

      .spot-card {
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 10px;
        background: #faf9f6;
        display: grid;
        gap: 8px;
      }

      .spot-row {
        display: grid;
        gap: 6px;
      }

      .spot-grid-2 {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
      }

      @media (max-width: 900px) {
        .controls {
          grid-template-columns: 1fr;
        }

        .locations-toolbar {
          grid-template-columns: 1fr;
        }

        .spot-grid-2 {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <main class="wrap">
      <section class="panel">
        <h1>Заявки на туры</h1>
        <p class="small">Админка для просмотра и обработки входящих заявок из Telegram Mini App.</p>
      </section>

      <section class="panel">
        <div class="controls">
          <input id="adminToken" placeholder="ADMIN_TOKEN" />
          <select id="statusFilter">
            <option value="">Все статусы</option>
            <option value="new">new</option>
            <option value="contacted">contacted</option>
            <option value="booked">booked</option>
            <option value="archived">archived</option>
          </select>
          <input id="searchInput" placeholder="Поиск: имя, телефон, место" />
          <button id="saveTokenBtn" class="secondary">Сохранить токен</button>
          <button id="refreshBtn">Обновить</button>
        </div>
        <p class="small" id="meta"></p>
      </section>

      <section class="panel table-wrap">
        <table>
          <thead>
            <tr>
              <th>ID</th>
              <th>Дата</th>
              <th>Клиент</th>
              <th>Контакт</th>
              <th>Маршрут</th>
              <th>Цена</th>
              <th>Статус</th>
              <th>Источник</th>
              <th>Действия</th>
            </tr>
          </thead>
          <tbody id="rows"></tbody>
        </table>
      </section>

      <section class="panel">
        <h2>Редактор локаций</h2>
        <p class="small">
          Меняйте описание, фото, категорию, регион, длительность и цену входного билета без правки кода.
        </p>
        <div class="locations-toolbar">
          <input id="spotSearchInput" placeholder="Поиск локации по названию/категории/региону" />
          <button id="bootstrapSpotsBtn" class="danger">Инициализировать локации</button>
          <button id="loadSpotsBtn">Загрузить локации</button>
          <button id="saveSpotsBtn" class="secondary">Сохранить изменения</button>
        </div>
        <p class="small" id="spotsMeta"></p>
        <div id="spotsList" class="spots-grid"></div>
      </section>
    </main>

    <script>
      const tokenEl = document.getElementById("adminToken");
      const statusFilterEl = document.getElementById("statusFilter");
      const searchInputEl = document.getElementById("searchInput");
      const refreshBtn = document.getElementById("refreshBtn");
      const saveTokenBtn = document.getElementById("saveTokenBtn");
      const rowsEl = document.getElementById("rows");
      const metaEl = document.getElementById("meta");

      const spotSearchInputEl = document.getElementById("spotSearchInput");
      const bootstrapSpotsBtn = document.getElementById("bootstrapSpotsBtn");
      const loadSpotsBtn = document.getElementById("loadSpotsBtn");
      const saveSpotsBtn = document.getElementById("saveSpotsBtn");
      const spotsMetaEl = document.getElementById("spotsMeta");
      const spotsListEl = document.getElementById("spotsList");

      const STATUSES = ["new", "contacted", "booked", "archived"];
      const SPOT_CATEGORIES = [
        "temples",
        "waterfalls",
        "terraces",
        "viewpoints",
        "beaches",
        "food",
        "animals",
        "relax",
      ];
      const SPOT_REGIONS = ["bali", "nusa_penida", "java", "other"];

      let leads = [];
      let spots = [];
      let spotsUpdatedAt = null;

      tokenEl.value = localStorage.getItem("adminToken") || "";

      saveTokenBtn.addEventListener("click", () => {
        localStorage.setItem("adminToken", tokenEl.value.trim());
        setMeta("Токен сохранен в браузере.");
        setSpotsMeta("Токен сохранен. Теперь можно загружать и сохранять локации.");
      });

      refreshBtn.addEventListener("click", loadLeads);
      statusFilterEl.addEventListener("change", loadLeads);
      searchInputEl.addEventListener("input", renderRows);

      bootstrapSpotsBtn.addEventListener("click", bootstrapSpots);
      loadSpotsBtn.addEventListener("click", loadSpots);
      saveSpotsBtn.addEventListener("click", saveSpots);
      spotSearchInputEl.addEventListener("input", renderSpots);

      function escapeText(value) {
        return (value || "").toString();
      }

      function formatMoney(value) {
        const number = Number(value || 0);
        return `${new Intl.NumberFormat("ru-RU").format(Math.round(number))} IDR`;
      }

      function formatDate(value) {
        if (!value) return "-";
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) return value;
        return date.toLocaleString("ru-RU");
      }

      function buildRouteText(lead) {
        const places = Array.isArray(lead.places) ? lead.places : [];
        const names = places.map((p) => p.name).filter(Boolean);
        const preview = names.slice(0, 4).join(" -> ");
        const suffix = names.length > 4 ? ` +${names.length - 4}` : "";
        return `${lead.route_days}д | ${lead.places_count} мест | ${preview}${suffix}`;
      }

      function setMeta(text, isError = false) {
        metaEl.textContent = text;
        metaEl.style.color = isError ? "#a0392a" : "#575146";
      }

      function setSpotsMeta(text, isError = false) {
        spotsMetaEl.textContent = text;
        spotsMetaEl.style.color = isError ? "#a0392a" : "#575146";
      }

      function normalizeSpot(raw) {
        if (!raw || typeof raw !== "object") return null;
        const name = String(raw.name || "").trim();
        if (!name) return null;

        const duration = Number(raw.duration);
        const ticket = Number(raw.ticket);

        return {
          name,
          region: String(raw.region || "bali").trim() || "bali",
          category: String(raw.category || "viewpoints").trim() || "viewpoints",
          duration: Number.isFinite(duration) && duration > 0 ? duration : 1,
          ticket: Number.isFinite(ticket) && ticket >= 0 ? Math.round(ticket) : 0,
          description: String(raw.description || "").trim(),
          image: String(raw.image || "").trim(),
          tip: String(raw.tip || "").trim(),
        };
      }

      async function loadDefaultSpotsFromAppJs() {
        const response = await fetch("/app.js", { cache: "no-store" });
        if (!response.ok) {
          throw new Error(`Не удалось загрузить app.js: HTTP ${response.status}`);
        }

        const source = await response.text();
        const start = source.indexOf("const CATEGORY_IMAGES = {");
        const end = source.indexOf("let CATALOG_SPOTS =");
        if (start === -1 || end === -1 || end <= start) {
          throw new Error("Не удалось найти дефолтный каталог в app.js");
        }

        const snippet = source.slice(start, end);
        const evaluator = new Function(`${snippet}\nreturn DEFAULT_CATALOG_SPOTS;`);
        const items = evaluator();
        if (!Array.isArray(items) || !items.length) {
          throw new Error("Дефолтный каталог пуст");
        }
        return items.map(normalizeSpot).filter(Boolean);
      }

      async function loadLeads() {
        const token = tokenEl.value.trim();
        const status = statusFilterEl.value;
        const params = new URLSearchParams({ limit: "250" });
        if (status) params.set("status", status);

        setMeta("Загружаю заявки...");
        rowsEl.innerHTML = "";

        try {
          const response = await fetch(`/api/leads?${params.toString()}`, {
            headers: {
              "X-Admin-Token": token,
            },
          });

          const data = await response.json().catch(() => ({}));
          if (!response.ok || !data.ok) {
            throw new Error(data.error || `HTTP ${response.status}`);
          }

          leads = Array.isArray(data.items) ? data.items : [];
          renderRows();
          setMeta(`Заявок: ${leads.length}`);
        } catch (error) {
          setMeta(`Ошибка: ${error.message}`, true);
        }
      }

      function filteredLeads() {
        const query = searchInputEl.value.trim().toLowerCase();
        if (!query) return leads;

        return leads.filter((lead) => {
          const places = Array.isArray(lead.places)
            ? lead.places.map((p) => p.name).join(" ")
            : "";
          const text = [
            lead.customer_name,
            lead.customer_phone,
            lead.customer_note,
            lead.source,
            places,
          ]
            .join(" ")
            .toLowerCase();
          return text.includes(query);
        });
      }

      async function updateStatus(leadId, status) {
        const token = tokenEl.value.trim();

        try {
          const response = await fetch(`/api/leads/${leadId}`, {
            method: "PATCH",
            headers: {
              "Content-Type": "application/json",
              "X-Admin-Token": token,
            },
            body: JSON.stringify({ status }),
          });
          const data = await response.json().catch(() => ({}));
          if (!response.ok || !data.ok) {
            throw new Error(data.error || `HTTP ${response.status}`);
          }

          const target = leads.find((item) => item.id === leadId);
          if (target) target.status = status;
          renderRows();
          setMeta(`Статус заявки #${leadId} обновлен на ${status}`);
        } catch (error) {
          setMeta(`Ошибка обновления #${leadId}: ${error.message}`, true);
        }
      }

      function renderRows() {
        rowsEl.innerHTML = "";

        const items = filteredLeads();
        if (!items.length) {
          const row = document.createElement("tr");
          const cell = document.createElement("td");
          cell.colSpan = 9;
          cell.textContent = "Заявки не найдены.";
          row.append(cell);
          rowsEl.append(row);
          return;
        }

        for (const lead of items) {
          const row = document.createElement("tr");

          const idCell = document.createElement("td");
          idCell.textContent = String(lead.id);

          const dateCell = document.createElement("td");
          dateCell.textContent = formatDate(lead.created_at);

          const customerCell = document.createElement("td");
          customerCell.textContent = escapeText(lead.customer_name);

          const contactCell = document.createElement("td");
          const travelDate = lead.travel_date ? ` | ${lead.travel_date}` : "";
          contactCell.textContent = `${escapeText(lead.customer_phone)}${travelDate}`;

          const routeCell = document.createElement("td");
          routeCell.textContent = buildRouteText(lead);

          const priceCell = document.createElement("td");
          const total =
            lead.pricing && typeof lead.pricing.total !== "undefined" ? lead.pricing.total : 0;
          priceCell.textContent = formatMoney(total);

          const statusCell = document.createElement("td");
          statusCell.className = `status status-${lead.status}`;
          statusCell.textContent = lead.status;

          const sourceCell = document.createElement("td");
          sourceCell.textContent = escapeText(lead.source || "-");

          const actionsCell = document.createElement("td");
          const actionWrap = document.createElement("div");
          actionWrap.className = "actions";

          const statusSelect = document.createElement("select");
          for (const status of STATUSES) {
            const option = document.createElement("option");
            option.value = status;
            option.textContent = status;
            if (status === lead.status) option.selected = true;
            statusSelect.append(option);
          }

          const saveBtn = document.createElement("button");
          saveBtn.textContent = "Сохранить";
          saveBtn.addEventListener("click", () => {
            updateStatus(lead.id, statusSelect.value);
          });

          actionWrap.append(statusSelect, saveBtn);
          actionsCell.append(actionWrap);

          row.append(
            idCell,
            dateCell,
            customerCell,
            contactCell,
            routeCell,
            priceCell,
            statusCell,
            sourceCell,
            actionsCell
          );
          rowsEl.append(row);
        }
      }

      function getIndexedSpots() {
        const query = spotSearchInputEl.value.trim().toLowerCase();
        return spots
          .map((spot, index) => ({ spot, index }))
          .filter(({ spot }) => {
            if (!query) return true;
            const text = [spot.name, spot.category, spot.region, spot.description]
              .join(" ")
              .toLowerCase();
            return text.includes(query);
          });
      }

      function createSelect(options, value, onChange) {
        const select = document.createElement("select");
        options.forEach((optionValue) => {
          const option = document.createElement("option");
          option.value = optionValue;
          option.textContent = optionValue;
          if (optionValue === value) option.selected = true;
          select.append(option);
        });
        select.addEventListener("change", () => onChange(select.value));
        return select;
      }

      function renderSpots() {
        spotsListEl.innerHTML = "";
        const items = getIndexedSpots();

        if (!items.length) {
          const empty = document.createElement("p");
          empty.className = "small";
          empty.textContent = spots.length
            ? "По фильтру ничего не найдено."
            : "Список локаций пуст. Откройте Mini App один раз и нажмите «Загрузить локации».";
          spotsListEl.append(empty);
          return;
        }

        for (const { spot, index } of items) {
          const card = document.createElement("article");
          card.className = "spot-card";

          const title = document.createElement("h3");
          title.textContent = spot.name;

          const gridTop = document.createElement("div");
          gridTop.className = "spot-grid-2";
          gridTop.append(
            createSelect(SPOT_CATEGORIES, spot.category, (value) => {
              spots[index].category = value;
            }),
            createSelect(SPOT_REGIONS, spot.region, (value) => {
              spots[index].region = value;
            })
          );

          const gridMid = document.createElement("div");
          gridMid.className = "spot-grid-2";

          const durationInput = document.createElement("input");
          durationInput.type = "number";
          durationInput.step = "0.1";
          durationInput.min = "0.1";
          durationInput.value = String(spot.duration);
          durationInput.placeholder = "Длительность (часы)";
          durationInput.addEventListener("input", () => {
            spots[index].duration = Number(durationInput.value) || 1;
          });

          const ticketInput = document.createElement("input");
          ticketInput.type = "number";
          ticketInput.min = "0";
          ticketInput.step = "1000";
          ticketInput.value = String(spot.ticket);
          ticketInput.placeholder = "Билет (IDR)";
          ticketInput.addEventListener("input", () => {
            spots[index].ticket = Math.max(0, Number(ticketInput.value) || 0);
          });

          gridMid.append(durationInput, ticketInput);

          const imageInput = document.createElement("input");
          imageInput.type = "url";
          imageInput.placeholder = "URL картинки";
          imageInput.value = spot.image || "";
          imageInput.addEventListener("input", () => {
            spots[index].image = imageInput.value.trim();
          });

          const desc = document.createElement("textarea");
          desc.rows = 3;
          desc.placeholder = "Описание локации";
          desc.value = spot.description || "";
          desc.addEventListener("input", () => {
            spots[index].description = desc.value.trim();
          });

          const tip = document.createElement("input");
          tip.placeholder = "Полезный совет";
          tip.value = spot.tip || "";
          tip.addEventListener("input", () => {
            spots[index].tip = tip.value.trim();
          });

          card.append(title, gridTop, gridMid, imageInput, desc, tip);
          spotsListEl.append(card);
        }
      }

      async function loadSpots() {
        setSpotsMeta("Загружаю локации...");
        spotsListEl.innerHTML = "";

        try {
          const response = await fetch("/api/spots");
          const data = await response.json().catch(() => ({}));
          if (!response.ok || !data.ok) {
            throw new Error(data.error || `HTTP ${response.status}`);
          }

          spots = Array.isArray(data.items) ? data.items.map(normalizeSpot).filter(Boolean) : [];
          spotsUpdatedAt = data.updated_at || null;
          renderSpots();

          if (!spots.length) {
            setSpotsMeta(
              "Локации пока не сохранены в базе. Нажмите «Инициализировать локации», затем «Загрузить локации».",
              true
            );
            return;
          }

          const updatedText = spotsUpdatedAt ? ` | Обновлено: ${formatDate(spotsUpdatedAt)}` : "";
          setSpotsMeta(`Локаций: ${spots.length}${updatedText}`);
        } catch (error) {
          setSpotsMeta(`Ошибка загрузки локаций: ${error.message}`, true);
        }
      }

      async function saveSpots() {
        const token = tokenEl.value.trim();
        if (!token) {
          setSpotsMeta("Введите ADMIN_TOKEN перед сохранением.", true);
          return;
        }

        const payload = spots.map(normalizeSpot).filter(Boolean);
        if (!payload.length) {
          setSpotsMeta("Сохранять нечего: список локаций пуст.", true);
          return;
        }

        setSpotsMeta("Сохраняю изменения...");

        try {
          const response = await fetch("/api/spots", {
            method: "PUT",
            headers: {
              "Content-Type": "application/json",
              "X-Admin-Token": token,
            },
            body: JSON.stringify({ items: payload }),
          });
          const data = await response.json().catch(() => ({}));
          if (!response.ok || !data.ok) {
            throw new Error(data.error || `HTTP ${response.status}`);
          }

          spots = payload;
          spotsUpdatedAt = data.updated_at || null;
          const updatedText = spotsUpdatedAt ? ` | Обновлено: ${formatDate(spotsUpdatedAt)}` : "";
          setSpotsMeta(`Сохранено: ${payload.length} локаций${updatedText}`);
        } catch (error) {
          setSpotsMeta(`Ошибка сохранения: ${error.message}`, true);
        }
      }

      async function bootstrapSpots() {
        setSpotsMeta("Инициализация дефолтных локаций...");

        try {
          const defaults = await loadDefaultSpotsFromAppJs();
          const response = await fetch("/api/spots/bootstrap", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ items: defaults }),
          });
          const data = await response.json().catch(() => ({}));
          if (!response.ok || !data.ok) {
            throw new Error(data.error || `HTTP ${response.status}`);
          }

          if (data.bootstrapped) {
            setSpotsMeta(`Инициализация выполнена: ${data.items_count} локаций.`);
          } else {
            setSpotsMeta(
              `Локации уже были в базе (${data.items_count}). Загружаю текущий список...`
            );
          }
          await loadSpots();
        } catch (error) {
          setSpotsMeta(`Ошибка инициализации: ${error.message}`, true);
        }
      }

      loadLeads();
      loadSpots();
    </script>
  </body>
</html>
